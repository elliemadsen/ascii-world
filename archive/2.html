<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>ASCII Room - Enhanced Lighting</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
        color: white;
        font-family: "Courier New", monospace;
      }
      #instructions {
        position: absolute;
        top: 50%;
        width: 100%;
        text-align: center;
        color: white;
        font-size: 20px;
        user-select: none;
        transform: translateY(-50%);
      }
    </style>
  </head>
  <body>
    <div id="instructions">Click to enter ASCII world</div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
      import { AsciiEffect } from "three/addons/effects/AsciiEffect.js";

      let camera, scene, renderer, effect, controls;
      let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false;
      let velocity = new THREE.Vector3();
      let direction = new THREE.Vector3();
      const clock = new THREE.Clock();

      init();
      animate();

      function init() {
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.set(0, 20, 0);

        scene = new THREE.Scene();

        // --- Lighting ---
        const light1 = new THREE.PointLight(0xffffff, 2);
        light1.position.set(80, 150, 80);
        scene.add(light1);

        const light2 = new THREE.PointLight(0x999999, 0.8);
        light2.position.set(-80, -100, -80);
        scene.add(light2);

        const ambient = new THREE.AmbientLight(0x222222);
        scene.add(ambient);

        // --- Room ---
        const roomSize = 300;
        const roomGeo = new THREE.BoxGeometry(
          roomSize,
          roomSize,
          roomSize,
          8,
          8,
          8
        );
        const roomMat = new THREE.MeshPhongMaterial({
          color: 0x000000,
          side: THREE.BackSide,
          flatShading: true,
        });
        const room = new THREE.Mesh(roomGeo, roomMat);
        scene.add(room);

        // --- Boxes with angular lighting variation ---
        const chars = " .,:;i1tfLCG08@".split(""); // smoother shading progression
        const materials = chars.map(
          (_, i) =>
            new THREE.MeshPhongMaterial({
              color: new THREE.Color().setHSL(0, 0, i / chars.length),
              emissive: 0x000000,
              flatShading: true,
            })
        );

        for (let i = 0; i < 12; i++) {
          const boxGeo = new THREE.BoxGeometry(20, 20, 20);
          const box = new THREE.Mesh(
            boxGeo,
            materials[Math.floor(Math.random() * materials.length)]
          );
          box.position.set(
            (Math.random() - 0.5) * roomSize * 0.8,
            10,
            (Math.random() - 0.5) * roomSize * 0.8
          );
          box.rotation.set(Math.random(), Math.random(), Math.random());
          scene.add(box);
        }

        // --- Renderer & ASCII effect ---
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Add a wide gradient of ASCII symbols to simulate surface contrast
        effect = new AsciiEffect(renderer, "   .:-=+*#%@▓█", { invert: false });
        effect.setSize(window.innerWidth, window.innerHeight);
        effect.domElement.style.color = "white";
        effect.domElement.style.backgroundColor = "black";
        effect.domElement.style.fontFamily = '"Courier New", monospace';
        document.body.appendChild(effect.domElement);

        // --- Controls ---
        controls = new PointerLockControls(camera, document.body);
        const instructions = document.getElementById("instructions");
        instructions.addEventListener("click", () => controls.lock());
        controls.addEventListener(
          "lock",
          () => (instructions.style.display = "none")
        );
        controls.addEventListener(
          "unlock",
          () => (instructions.style.display = "")
        );

        scene.add(controls.object);

        // --- Keyboard movement (arrow keys) ---
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);
        window.addEventListener("resize", onWindowResize);
      }

      function onKeyDown(event) {
        switch (event.code) {
          case "ArrowUp":
            moveForward = true;
            break;
          case "ArrowDown":
            moveBackward = true;
            break;
          case "ArrowLeft":
            moveLeft = true;
            break;
          case "ArrowRight":
            moveRight = true;
            break;
        }
      }

      function onKeyUp(event) {
        switch (event.code) {
          case "ArrowUp":
            moveForward = false;
            break;
          case "ArrowDown":
            moveBackward = false;
            break;
          case "ArrowLeft":
            moveLeft = false;
            break;
          case "ArrowRight":
            moveRight = false;
            break;
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        effect.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        const speed = 80.0;
        const damping = 10.0;

        velocity.x -= velocity.x * damping * delta;
        velocity.z -= velocity.z * damping * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        if (moveForward || moveBackward)
          velocity.z -= direction.z * speed * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);

        effect.render(scene, camera);
      }
    </script>
  </body>
</html>
