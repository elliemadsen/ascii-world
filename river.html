<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>river</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Courier New", monospace;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
      import { AsciiEffect } from "three/addons/effects/AsciiEffect.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { Water } from "three/addons/objects/Water.js";
      import { TextureLoader } from "three";
      import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/loaders/OBJLoader.js";

      let camera, scene, renderer, effect, controls;
      const keys = {};
      let asciiEnabled = true;

      init();
      animate();

      function init() {
        // --- Scene ---
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // --- Camera ---
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 20, 30);

        // --- Lights ---

        // Harsh directional sunlight
        const sunLight = new THREE.DirectionalLight(0xffffff, 2);
        sunLight.position.set(50, 80, -50);
        scene.add(sunLight);

        // Ambient fill light
        const ambient = new THREE.AmbientLight(0x333333);
        scene.add(ambient);

        // === CURVY, WINDY RIVER USING Water() MATERIAL ===
        const riverLength = 2000;
        const riverWidth = 40;
        const riverGeometry = new THREE.PlaneGeometry(
          riverWidth,
          riverLength,
          100,
          100
        );

        // Rotate to lie flat
        riverGeometry.rotateX(-Math.PI / 2);

        // === Utility: get curve X offset for a given Z ===
        function riverCurveX(z) {
          const t = (z + riverLength / 2) / riverLength;

          // Same curves you used for the river geometry
          const bigCurve = Math.sin(t * Math.PI * 2) * 60;
          const smallCurve = Math.sin(t * Math.PI * 6) * 30;

          return bigCurve + smallCurve;
        }

        // ----- MAKE THE RIVER WINDY -----
        const pos = riverGeometry.attributes.position;
        for (let i = 0; i < pos.count; i++) {
          pos.setX(i, pos.getX(i) + riverCurveX(pos.getZ(i)));
        }

        pos.needsUpdate = true;

        // ----- LOAD NORMAL MAP -----
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
          "https://threejs.org/examples/textures/water/Water_1_M_Normal.jpg",
          (waterNormals) => {
            waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;

            // ----- WATER MATERIAL -----
            const water = new Water(riverGeometry, {
              textureWidth: 1024,
              textureHeight: 1024,
              waterNormals: waterNormals,
              sunDirection: new THREE.Vector3(1, 1, 1),
              sunColor: 0xffffff,
              waterColor: 0xffffff,
              distortionScale: 10.0,
              fog: false,
            });

            // Put it directly in front of camera
            water.position.set(0, 0, -400);

            scene.add(water);
            scene.userData.river = water;
          }
        );

        // === Landscaping: trees along the river ===
        const gltfLoader = new GLTFLoader();

        const riverLengthStart = -400; // where you positioned the river

        const treeDistance = 10; // distance from river edge
        const treesPerSide = 20; // adjust for density

        const riverZStart = riverLengthStart - riverLength / 2;

        for (let i = 0; i < treesPerSide; i++) {
          const t = i / (treesPerSide - 1);
          const z = riverZStart + t * riverLength; // evenly spaced along river

          const objLoader = new OBJLoader();

          objLoader.load(
            "models/landscape/79-low-poly-tree/Low Poly Tree.obj",
            (tree) => {
              const riverCenterX = riverCurveX(z);
              const side = Math.random() < 0.5 ? -1 : 1;
              const distanceFromRiver =
                riverWidth / 2 + treeDistance + Math.random() * 4;
              const x = riverCenterX + side * distanceFromRiver;

              tree.scale.setScalar(3);
              tree.position.set(x, 0, z);
              tree.rotation.y = Math.random() * Math.PI * 2;
              scene.add(tree);
            }
          );

          objLoader.load(
            "models/landscape/10445_Oak_Tree_v1/10445_Oak_Tree_v1_max2010_iteration-1.obj",
            (tree) => {
              const riverCenterX = riverCurveX(z);
              const side = Math.random() < 0.5 ? -1 : 1;
              const distanceFromRiver =
                riverWidth / 2 + treeDistance + Math.random() * 2;
              const x = riverCenterX + side * distanceFromRiver;

              tree.scale.setScalar(0.08);
              tree.position.set(x, 0, z);
              tree.rotation.x = -Math.PI / 2;
              scene.add(tree);
            }
          );
        }

        // --- Renderer & ASCII ---
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        effect = new AsciiEffect(renderer, " .,!%$#@", {
          invert: true,
          resolution: 0.3,
        });
        effect.setSize(window.innerWidth, window.innerHeight);
        effect.domElement.style.color = "white";
        effect.domElement.style.backgroundColor = "black";
        effect.domElement.style.fontFamily = '"Courier New", monospace';
        effect.domElement.style.pointerEvents = "none";
        document.body.appendChild(effect.domElement);

        // --- Controls ---
        controls = new PointerLockControls(camera, document.body);
        document.body.addEventListener("click", () => {
          controls.lock();
        });

        document.addEventListener("keydown", (e) => (keys[e.key] = true));
        document.addEventListener("keyup", (e) => (keys[e.key] = false));

        // Toggle ASCII on/off
        window.addEventListener("keydown", (e) => {
          if (e.key === "a") asciiEnabled = !asciiEnabled;
        });

        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        effect.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        // --- Camera movement ---
        const speed = 0.6;
        if (keys["ArrowUp"]) controls.moveForward(speed);
        if (keys["ArrowDown"]) controls.moveForward(-speed);
        if (keys["ArrowLeft"]) controls.getObject().rotation.y += 0.03;
        if (keys["ArrowRight"]) controls.getObject().rotation.y -= 0.03;

        if (scene.userData.river) {
          scene.userData.river.material.uniforms.time.value += 0.02;
        }

        // --- Render ASCII or normal ---
        if (asciiEnabled) {
          effect.render(scene, camera);
          effect.domElement.style.display = "block";
          renderer.domElement.style.display = "none";
        } else {
          renderer.render(scene, camera);
          effect.domElement.style.display = "none";
          renderer.domElement.style.display = "block";
        }
      }
    </script>
  </body>
</html>
